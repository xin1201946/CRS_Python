import{r as e,aF as n,aG as s}from"./index-BEnZJKm2.js";const a={},t=(e,n,s,t)=>{l(s)&&a[s]||(l(s)&&(a[s]=new Date),((e,n,s,a)=>{var t,r,o,i;const u=[s,{code:n,...a||{}}];if(null==(r=null==(t=null==e?void 0:e.services)?void 0:t.logger)?void 0:r.forward)return e.services.logger.forward(u,"warn","react-i18next::",!0);l(u[0])&&(u[0]=`react-i18next:: ${u[0]}`),(null==(i=null==(o=null==e?void 0:e.services)?void 0:o.logger)?void 0:i.warn)?e.services.logger.warn(...u):null==console||console.warn})(e,n,s,t))},r=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout((()=>{e.off("initialized",s)}),0),n()};e.on("initialized",s)}},o=(e,n,s)=>{e.loadNamespaces(n,r(e,s))},i=(e,n,s,a)=>{if(l(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return o(e,s,a);s.forEach((n=>{e.options.ns.indexOf(n)<0&&e.options.ns.push(n)})),e.loadLanguages(n,r(e,a))},l=e=>"string"==typeof e,u=e.createContext();class c{constructor(){this.usedNamespaces={}}addUsedNamespaces(e){e.forEach((e=>{this.usedNamespaces[e]||(this.usedNamespaces[e]=!0)}))}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const d=(e,n,s,a)=>e.getFixedT(n,s,a),g=(a,r={})=>{var g,f,p,N;const{i18n:h}=r,{i18n:m,defaultNS:v}=e.useContext(u)||{},w=h||m||n();if(w&&!w.reportNamespaces&&(w.reportNamespaces=new c),!w){t(w,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const e=(e,n)=>{return l(n)?n:"object"==typeof(s=n)&&null!==s&&l(n.defaultValue)?n.defaultValue:Array.isArray(e)?e[e.length-1]:e;var s},n=[e,{},!1];return n.t=e,n.i18n={},n.ready=!1,n}(null==(g=w.options.react)?void 0:g.wait)&&t(w,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const y={...s(),...w.options.react,...r},{useSuspense:x,keyPrefix:E}=y;let b=v||(null==(f=w.options)?void 0:f.defaultNS);b=l(b)?[b]:b||["translation"],null==(N=(p=w.reportNamespaces).addUsedNamespaces)||N.call(p,b);const I=(w.isInitialized||w.initializedStoreOnce)&&b.every((e=>((e,n,s={})=>n.languages&&n.languages.length?n.hasLoadedNamespace(e,{lng:s.lng,precheck:(n,a)=>{var t;if((null==(t=s.bindI18n)?void 0:t.indexOf("languageChanging"))>-1&&n.services.backendConnector.backend&&n.isLanguageChangingTo&&!a(n.isLanguageChangingTo,e))return!1}}):(t(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0))(e,w,y))),T=((n,s,a,t)=>e.useCallback(d(n,s,a,t),[n,s,a,t]))(w,r.lng||null,"fallback"===y.nsMode?b:b[0],E),C=()=>T,O=()=>d(w,r.lng||null,"fallback"===y.nsMode?b:b[0],E),[S,k]=e.useState(C);let A=b.join();r.lng&&(A=`${r.lng}${A}`);const z=((n,s)=>{const a=e.useRef();return e.useEffect((()=>{a.current=n}),[n,s]),a.current})(A),L=e.useRef(!0);e.useEffect((()=>{const{bindI18n:e,bindI18nStore:n}=y;L.current=!0,I||x||(r.lng?i(w,r.lng,b,(()=>{L.current&&k(O)})):o(w,b,(()=>{L.current&&k(O)}))),I&&z&&z!==A&&L.current&&k(O);const s=()=>{L.current&&k(O)};return e&&(null==w||w.on(e,s)),n&&(null==w||w.store.on(n,s)),()=>{L.current=!1,w&&(null==e||e.split(" ").forEach((e=>w.off(e,s)))),n&&w&&n.split(" ").forEach((e=>w.store.off(e,s)))}}),[w,A]),e.useEffect((()=>{L.current&&I&&k(C)}),[w,E,I]);const j=[S,w,I];if(j.t=S,j.i18n=w,j.ready=I,I)return j;if(!I&&!x)return j;throw new Promise((e=>{r.lng?i(w,r.lng,b,(()=>e())):o(w,b,(()=>e()))}))};export{g as u};
