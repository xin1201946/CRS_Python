import{q as e,r as t,B as r,R as o,J as s,as as n,P as i,z as a,A as c,D as l,F as u,K as p}from"./index-CiQzaChg.js";import{a as f,_ as h}from"./index-DAldieki.js";import{R as d}from"./index-CpoOHKow.js";const v=e((function(e){return t.createElement("svg",Object.assign({viewBox:"0 0 24 24",fill:"none",xmlns:"http://www.w3.org/2000/svg",width:"1em",height:"1em",focusable:!1,"aria-hidden":!0},e),t.createElement("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M16.28 4.24a1.5 1.5 0 0 1 0 2.12l-5.66 5.66 5.66 5.65a1.5 1.5 0 1 1-2.12 2.13l-6.72-6.72a1.5 1.5 0 0 1 0-2.12l6.72-6.72a1.5 1.5 0 0 1 2.12 0Z",fill:"currentColor"}))}),"chevron_left");var m=Function.prototype.toString,y=Object.create,g=Object.prototype.toString,b=function(){function e(){this._keys=[],this._values=[]}return e.prototype.has=function(e){return!!~this._keys.indexOf(e)},e.prototype.get=function(e){return this._values[this._keys.indexOf(e)]},e.prototype.set=function(e,t){this._keys.push(e),this._values.push(t)},e}();var O="undefined"!=typeof WeakMap?function(){return new WeakMap}:function(){return new b};function w(e){if(!e)return y(null);var t=e.constructor;if(t===Object)return e===Object.prototype?{}:y(e);if(t&&~m.call(t).indexOf("[native code]"))try{return new t}catch(r){}return y(e)}var S="g"===/test/g.flags?function(e){return e.flags}:function(e){var t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t};function R(e){var t=g.call(e);return t.substring(8,t.length-1)}var M="undefined"!=typeof Symbol?function(e){return e[Symbol.toStringTag]||R(e)}:R,I=Object.defineProperty,E=Object.getOwnPropertyDescriptor,j=Object.getOwnPropertyNames,_=Object.getOwnPropertySymbols,C=Object.prototype,A=C.hasOwnProperty,P=C.propertyIsEnumerable,k="function"==typeof _;var x=k?function(e){return j(e).concat(_(e))}:j;function W(e,t,r){for(var o=x(e),s=0,n=o.length,i=void 0,a=void 0;s<n;++s)if("callee"!==(i=o[s])&&"caller"!==i)if(a=E(e,i)){a.get||a.set||(a.value=r.copier(a.value,r));try{I(t,i,a)}catch(c){t[i]=a.value}}else t[i]=r.copier(e[i],r);return t}function D(e,t){return e.slice(0)}function B(e,t){var r=new t.Constructor;return t.cache.set(e,r),e.forEach((function(e,o){r.set(o,t.copier(e,t))})),r}var N=k?function(e,t){var r=w(t.prototype);for(var o in t.cache.set(e,r),e)A.call(e,o)&&(r[o]=t.copier(e[o],t));for(var s=_(e),n=0,i=s.length,a=void 0;n<i;++n)a=s[n],P.call(e,a)&&(r[a]=t.copier(e[a],t));return r}:function(e,t){var r=w(t.prototype);for(var o in t.cache.set(e,r),e)A.call(e,o)&&(r[o]=t.copier(e[o],t));return r};function z(e,t){return new t.Constructor(e.valueOf())}function T(e,t){return e}function L(e,t){var r=new t.Constructor;return t.cache.set(e,r),e.forEach((function(e){r.add(t.copier(e,t))})),r}var F=Array.isArray,U=Object.assign,V=Object.getPrototypeOf||function(e){return e.__proto__},Y={array:function(e,t){var r=new t.Constructor;t.cache.set(e,r);for(var o=0,s=e.length;o<s;++o)r[o]=t.copier(e[o],t);return r},arrayBuffer:D,blob:function(e,t){return e.slice(0,e.size,e.type)},dataView:function(e,t){return new t.Constructor(D(e.buffer))},date:function(e,t){return new t.Constructor(e.getTime())},error:T,map:B,object:N,regExp:function(e,t){var r=new t.Constructor(e.source,S(e));return r.lastIndex=e.lastIndex,r},set:L},K=U({},Y,{array:function(e,t){var r=new t.Constructor;return t.cache.set(e,r),W(e,r,t)},map:function(e,t){return W(e,B(e,t),t)},object:function(e,t){var r=w(t.prototype);return t.cache.set(e,r),W(e,r,t)},set:function(e,t){return W(e,L(e,t),t)}});function $(e){var t=function(e){return{Arguments:e.object,Array:e.array,ArrayBuffer:e.arrayBuffer,Blob:e.blob,Boolean:z,DataView:e.dataView,Date:e.date,Error:e.error,Float32Array:e.arrayBuffer,Float64Array:e.arrayBuffer,Int8Array:e.arrayBuffer,Int16Array:e.arrayBuffer,Int32Array:e.arrayBuffer,Map:e.map,Number:z,Object:e.object,Promise:T,RegExp:e.regExp,Set:e.set,String:z,WeakMap:T,WeakSet:T,Uint8Array:e.arrayBuffer,Uint8ClampedArray:e.arrayBuffer,Uint16Array:e.arrayBuffer,Uint32Array:e.arrayBuffer,Uint64Array:e.arrayBuffer}}(U({},Y,e)),r=t.Array,o=t.Object;function s(e,s){if(s.prototype=s.Constructor=void 0,!e||"object"!=typeof e)return e;if(s.cache.has(e))return s.cache.get(e);if(s.prototype=V(e),s.Constructor=s.prototype&&s.prototype.constructor,!s.Constructor||s.Constructor===Object)return o(e,s);if(F(e))return r(e,s);var n=t[M(e)];return n?n(e,s):"function"==typeof e.then?e:o(e,s)}return function(e){return s(e,{Constructor:void 0,cache:O(),copier:s,prototype:void 0})}}$(U({},K,{}));var G=$({});const X={PREFIX:r+"-overflow-list"},q={COLLAPSE:"collapse",SCROLL:"scroll"},J={START:"start",END:"end"},Z={BOUNDARY_SET:Object.values(J),POSITION_SET:["vertical","horizontal"],MODE_SET:Object.values(q),MODE_MAP:q,BOUNDARY_MAP:J,OVERFLOW_DIR:{GROW:1}},H=4;class Q extends o.PureComponent{componentDidMount(){const{items:e}=this.props;this.cachedKeys=Object.keys(e);const{root:t,threshold:r,rootMargin:o,option:s,onIntersect:n}=this.props;this.observer=new IntersectionObserver(n,Object.assign({root:t,threshold:r,rootMargin:o},s)),this.observeElement()}componentDidUpdate(){const{items:e}=this.props,t=Object.keys(e);s(this.cachedKeys,t)||(this.observeElement(!0),this.cachedKeys=t)}componentWillUnmount(){this.observer&&(this.observer.disconnect(),this.observer=null)}observeElement(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const{items:t}=this.props;f(t)?this.observer.disconnect():(e&&this.observer.disconnect(),Object.keys(t).forEach((e=>{const r=t[e];r&&n(r)&&this.observer.observe(r)})))}render(){const{children:e}=this.props;return e}}Q.propTypes={onIntersect:i.func,option:i.object,root:i.any,threshold:i.number,rootMargin:i.string,items:i.object},Q.defaultProps={onIntersect:()=>{},threshold:.75,rootMargin:"0px",option:{},items:{}};const ee=Z.BOUNDARY_MAP;class te extends a{constructor(e){super(Object.assign({},e)),this.previousY=void 0,this.isScrollMode=()=>{const{renderMode:e}=this.getProps();return"scroll"===e},this.getReversedItems=()=>{const{items:e}=this.getProps();return G(e).reverse()}}getOverflowItem(){const{items:e}=this.getProps(),{visibleState:t,overflow:r}=this.getStates();if(!this.isScrollMode())return r;const o=e.map((e=>{let{key:r}=e;return Boolean(t.get(r))})),s=o.indexOf(!0),n=o.lastIndexOf(!0),i=[];return i[0]=s>=0?e.slice(0,s):[],i[1]=n>=0?e.slice(n+1,e.length):e.slice(),i}handleIntersect(e){const t=G(this.getState("visibleState")),r={};e.forEach((e=>{const o=c(e,"target.dataset.scrollkey"),s=e.isIntersecting;r[o]=e,t.set(o,s)}));let o=!1;for(const a of t.values())if(a){o=!0;break}const s=o,[n]=e,i=n.boundingClientRect.y;s||void 0===this.previousY||i===this.previousY?(this.previousY=i,this._adapter.updateVisibleState(t),this._adapter.notifyIntersect(r)):this.previousY=i}handleCollapseOverflow(){const{minVisibleItems:e,collapseFrom:t}=this.getProps(),{overflowWidth:r,containerWidth:o,pivot:s,overflowStatus:n}=this.getStates(),{items:i,onOverflow:a}=this.getProps();let c=r,l=0,u=!1;for(const p of this._adapter.getItemSizeMap().values()){if(c+=p,c>o){u=!0;break}if(l===i.length-1){this._adapter.updateStates({overflowStatus:"normal",pivot:i.length-1,visible:i,overflow:[]});break}l++}if(u){const r=Math.max(e,l),o=t===ee.START,n=o?this.getReversedItems().slice(0,r).reverse():i.slice(0,r),c=o?this.getReversedItems().slice(r).reverse():i.slice(r);return this._adapter.updateStates({overflowStatus:"overflowed",pivot:r,visible:n,overflow:c}),void(s!==r&&a(c))}}}const re=X.PREFIX,oe=Z.BOUNDARY_MAP,se=Z.OVERFLOW_DIR,ne=Z.MODE_MAP;class ie extends l{constructor(e){var t;super(e),t=this,this.scroller=null,this.spacer=null,this.isScrollMode=()=>{const{renderMode:e}=this.props;return e===ne.SCROLL},this.resize=function(){var e;const r=null===(e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[])[0])||void 0===e?void 0:e.target.clientWidth;t.setState({containerWidth:r,overflowStatus:"calculating"})},this.reintersect=e=>{this.foundation.handleIntersect(e)},this.mergeRef=(e,t,r)=>{this.itemRefs[r]=t,"function"==typeof e?e(t):"object"==typeof e&&e&&"current"in e&&(e.current=t)},this.renderOverflow=()=>{const e=this.foundation.getOverflowItem();return this.props.overflowRenderer(e)},this.getItemKey=(e,t)=>{const{itemKey:r}=this.props;return h(r)?r(e):c(e,r||"key",t)},this.renderItemList=()=>{const{className:e,wrapperClassName:t,wrapperStyle:r,style:s,visibleItemRenderer:n,renderMode:i,collapseFrom:a}=this.props,{visible:c,overflowStatus:l}=this.state;let p=this.renderOverflow();if(!this.isScrollMode()&&(Array.isArray(p)&&(p=o.createElement(o.Fragment,null,p)),o.isValidElement(p))){const e=o.cloneElement(p);p=o.createElement(d,{onResize:e=>{let[t]=e;this.setState({overflowWidth:t.target.clientWidth,overflowStatus:"calculating"})}},o.createElement("div",{className:`${re}-overflow`},e))}const f=i===ne.SCROLL?(()=>{const e=[o.createElement("div",{className:u(t,`${re}-scroll-wrapper`),ref:e=>{this.scroller=e},style:Object.assign({},r),key:`${re}-scroll-wrapper`},c.map(n).map((e=>{const{forwardRef:t,key:r}=e;return o.cloneElement(e,{ref:e=>this.mergeRef(t,e,r),"data-scrollkey":`${r}`,key:r})})))];return"both"===this.props.overflowRenderDirection?(e.unshift(p[0]),e.push(p[1])):"start"===this.props.overflowRenderDirection?(e.unshift(p[1]),e.unshift(p[0])):(e.push(p[0]),e.push(p[1])),e})():[a===oe.START?p:null,c.map(((e,t)=>{const{key:r}=e,s=n(e,t),i=o.cloneElement(s);return o.createElement(d,{key:null!=r?r:t,onResize:r=>{let[o]=r;return this.onItemResize(o,e,t)}},o.createElement("div",{key:null!=r?r:t,className:`${re}-item`},i))})),a===oe.END?p:null];return o.createElement("div",{className:u(`${re}`,e),style:Object.assign(Object.assign({},s),i===ne.COLLAPSE?{maxWidth:"100%",visibility:"calculating"===l?"hidden":"visible"}:null)},...f)},this.onItemResize=(e,t,r)=>{const o=this.getItemKey(t,r),s=this.itemSizeMap.get(o);s?s!==e.target.clientWidth&&(this.itemSizeMap.set(o,e.target.clientWidth),this.setState({overflowStatus:"calculating"})):this.itemSizeMap.set(o,e.target.clientWidth);const{maxCount:n}=this.state;this.itemSizeMap.size===n&&this.setState({overflowStatus:"calculating"})},this.state={direction:se.GROW,lastOverflowCount:0,overflow:[],visible:[],containerWidth:0,visibleState:new Map,itemSizeMap:new Map,overflowStatus:"calculating",pivot:-1,overflowWidth:0,maxCount:0},this.foundation=new te(this.adapter),this.previousWidths=new Map,this.itemRefs={},this.itemSizeMap=new Map}static getDerivedStateFromProps(e,t){const{prevProps:r}=t,o={};o.prevProps=e;const n=t=>!r&&t in e||r&&!s(r[t],e[t]);if(n("items")||n("style")){if(o.direction=se.GROW,o.lastOverflowCount=0,o.maxCount=0,e.renderMode===ne.SCROLL)o.visible=e.items,o.overflow=[];else{let r=e.items.length;0!==Math.floor(t.containerWidth/H)&&(r=Math.min(r,Math.floor(t.containerWidth/H)));const s=e.collapseFrom===oe.START,n=s?G(e.items).reverse().slice(0,r):e.items.slice(0,r),i=s?G(e.items).reverse().slice(r):e.items.slice(r);o.visible=n,o.overflow=i,o.maxCount=r}o.pivot=-1,o.overflowStatus="calculating"}return o}get adapter(){return Object.assign(Object.assign({},super.adapter),{updateVisibleState:e=>{this.setState({visibleState:e},(()=>{var t,r;null===(r=(t=this.props).onVisibleStateChange)||void 0===r||r.call(t,e)}))},updateStates:e=>{this.setState(Object.assign({},e))},notifyIntersect:e=>{this.props.onIntersect&&this.props.onIntersect(e)},getItemSizeMap:()=>this.itemSizeMap})}componentDidUpdate(e,t){const r=e.items.map((e=>e.key)),o=this.props.items.map((e=>e.key));s(r,o)||(this.itemRefs={},this.setState({visibleState:new Map}));const{overflow:n,containerWidth:i,visible:a,overflowStatus:c}=this.state;this.isScrollMode()||"calculating"!==c||this.foundation.handleCollapseOverflow()}render(){const e=this.renderItemList(),{renderMode:t}=this.props;return t===ne.SCROLL?o.createElement(Q,{onIntersect:this.reintersect,root:this.scroller,threshold:this.props.threshold,items:this.itemRefs},e):o.createElement(d,{onResize:this.resize},e)}}ie.__SemiComponentName__="OverflowList",ie.defaultProps=p(ie.__SemiComponentName__,{collapseFrom:"end",minVisibleItems:0,overflowRenderer:()=>null,renderMode:"collapse",threshold:.75,visibleItemRenderer:()=>null,onOverflow:()=>null,overflowRenderDirection:"both"}),ie.propTypes={className:i.string,collapseFrom:i.oneOf(Z.BOUNDARY_SET),direction:i.oneOf(Z.POSITION_SET),items:i.array,minVisibleItems:i.number,onIntersect:i.func,onOverflow:i.func,overflowRenderer:i.func,renderMode:i.oneOf(Z.MODE_SET),style:i.object,threshold:i.number,visibleItemRenderer:i.func,wrapperClassName:i.string,wrapperStyle:i.object,collapseMask:i.object,overflowRenderDirection:i.string};export{v as I,ie as O};
